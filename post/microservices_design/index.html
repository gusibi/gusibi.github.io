<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>《微服务设计》读书笔记 | 顾斯比</title>
<link rel="shortcut icon" href="http://blog.gusibi.site/favicon.ico?v=1594308206371">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="http://blog.gusibi.site/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="《微服务设计》读书笔记 | 顾斯比 - Atom Feed" href="http://blog.gusibi.site/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-76238744-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-76238744-1');
</script>


    <meta name="description" content="📖阅读的目的
微服务是一种分布式系统解决方案，最近几年工作中使用的是微服务架构来部署服务，但自己接触到的主要是业务开发相关的工作，对微服务的了解主要偏实战方面，而对于构建、集成、分解、测试、部署、监控、架构演进等相关内容没有系统性的了解过..." />
    <meta name="keywords" content="微服务,读书笔记" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="http://blog.gusibi.site">
  <img class="avatar" src="http://blog.gusibi.site/images/avatar.png?v=1594308206371" alt="">
  </a>
  <h1 class="site-title">
    顾斯比
  </h1>
  <p class="site-description">
    这个人很懒
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?eb5ce2e96866802764816b111f5a3ffb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/gusibi" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
        <a href="https://twitter.com/amazing_gs" target="_blank">
          <i class="ri-twitter-line"></i>
        </a>
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              《微服务设计》读书笔记
            </h2>
            <div class="post-info">
              <span>
                2020-06-26
              </span>
              <span>
                12 min read
              </span>
              
                <a href="http://blog.gusibi.site/tag/wLh2QeTbc/" class="post-tag">
                  # 微服务
                </a>
              
                <a href="http://blog.gusibi.site/tag/R03AJFQeGg/" class="post-tag">
                  # 读书笔记
                </a>
              
            </div>
            
              <img class="post-feature-image" src="http://blog.gusibi.site/post-images/microservices_design.jpeg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h3 id="阅读的目的">📖阅读的目的</h3>
<p>微服务是一种分布式系统解决方案，最近几年工作中使用的是微服务架构来部署服务，但自己接触到的主要是业务开发相关的工作，对微服务的了解主要偏实战方面，而对于构建、集成、分解、测试、部署、监控、架构演进等相关内容没有系统性的了解过，此书内容比较全面，包含了微服务设计的各种主题，读这本书主要希望可以系统性的了解一下微服务的方方面面。</p>
<h3 id="️本书的整体框架">⚓️本书的整体框架</h3>
<p>这本书主要基于主题来组织内容，主要包含以下主题：</p>
<ol>
<li>微服务基本概念的介绍，</li>
<li>如何构建微服务，</li>
<li>什么样的服务集成技术对微服务最有帮助，</li>
<li>如何把一个大的单块系统分解成微服务，</li>
<li>如何部署微服务，</li>
<li>如何测试微服务以确保软件质量，</li>
<li>对于复杂的分布式系统如何监控，</li>
<li>如何安全的使用微服务，</li>
<li>使用康威定律解释开发人员组织结构和系统设计的相互租用，</li>
<li>介绍规模化后微服务面临的问题以及符合应对问题。</li>
</ol>
<p>这篇文章只是选取书中部分观点拿来讨论，不是总结和概括。</p>
<h3 id="本书的目录">本书的目录</h3>
<figure data-type="image" tabindex="1"><img src="http://media.gusibi.mobi/B2JeYMCE2L_M5LZb_lJIODgQWBBKZluLNgop3BeRuQ0wD5xs07hdDYAdtYxcCfI3" alt="微服务设计.png" loading="lazy"></figure>
<h3 id="微服务定义">微服务定义</h3>
<p>对于微服务，作者定义为一些协同工作的小而自治的服务，“小而自治”可以使用单一职责原则来解释：把因相同原因而变化的东西聚合在一起，而把因不同原因而变化的东西分离开。这个原则也可以用来指导单个服务的微服务拆分。</p>
<p><strong>多小算小</strong>：</p>
<p>澳大利亚RealEstate.com.au的Jon Eaves认为，一个微服务应该可以在两周内完全重写。服务是否够小，作者认为需要考虑以下因素：</p>
<ol>
<li>服务越小，微服务架构的优点和缺点也就越明显</li>
<li>微服务越小，独立性带来的好处就越多，但也就越复杂</li>
<li>如果开发者不再觉得代码库过大，那就可以认为足够小了。</li>
</ol>
<p><strong>自治：</strong></p>
<p>一个微服务是一个独立的实体，独立部署，服务之间通过网络调用进行通信，从而加强服务之间的隔离性，避免耦合。</p>
<p><strong>微服务的优点：</strong></p>
<ol>
<li>技术异构性：因为单个微服务力度足够小，在由多个微服务组成的系统中，可以在不同的微服务中使用不同的技术，比如使用不同的语言、框架、不同的数据库等。</li>
<li>弹性：微服务可以部署在多个机器上来降低功能完全不可用的概率，这样当一个服务不可用时也可以避免级联故障的产生。</li>
<li>扩展：可以对特定的模块进行扩展或缩容，比如性能要求高的部署在性能好的机器上，性能要求低的部署在性能稍差的机器上</li>
<li>简化部署：部署时只需要部署修改的部分而不是把整个大的服务。</li>
<li>与组织架构相匹配：不同模块由不同的人员维护开发</li>
<li>可替代性：对于大的服务，重构替代比较难，但是微服务就相对简单，可能只需要几天就能完成。</li>
</ol>
<p>微服务虽然好处很多，但是微服务并不是没有缺点，更不是银弹，使用微服务之前需要考虑清除。</p>
<h3 id="架构师">架构师</h3>
<p>架构师的一个重要职责是确保团队有共同的技术愿景，以帮助我们向客户交付他们想要的系统。</p>
<p>作者有一个观点特别有意思，他认为架构师是参考其它行业比如建筑师来命名的，但是“架构师”并不需要像“建筑师”那样需要对设计保证足够的精确，且对产物负有不可推卸的责任，但是软件“架构师”却需要保证软件有足够的灵活性和适应性，并且能够根据用户的需求进行演化。这么看来，软件设计师更像是城市规划师，只需要保证大方向上的正确，对于模块内的具体设计可以随机应变。</p>
<h3 id="指导原则">指导原则</h3>
<p>软件设计的关键是取舍，而哪些取哪些舍就需要满足一些原则，而原则本身也需要取舍，最好不要超过10条，否则当原则太多可能会产生冲突也不便记忆，可以参考【1】 https://www.12factor.net/zh_cn/ 的12项原则:</p>
<h4 id="i-基准代码"><a href="https://www.12factor.net/zh_cn/codebase">I. 基准代码</a></h4>
<p>一份基准代码，多份部署</p>
<h4 id="ii-依赖"><a href="https://www.12factor.net/zh_cn/dependencies">II. 依赖</a></h4>
<p>显式声明依赖关系</p>
<h4 id="iii-配置"><a href="https://www.12factor.net/zh_cn/config">III. 配置</a></h4>
<p>在环境中存储配置</p>
<h4 id="iv-后端服务"><a href="https://www.12factor.net/zh_cn/backing-services">IV. 后端服务</a></h4>
<p>把后端服务当作附加资源</p>
<h4 id="v-构建发布运行"><a href="https://www.12factor.net/zh_cn/build-release-run">V. 构建，发布，运行</a></h4>
<p>严格分离构建和运行</p>
<h4 id="vi-进程"><a href="https://www.12factor.net/zh_cn/processes">VI. 进程</a></h4>
<p>以一个或多个无状态进程运行应用</p>
<h4 id="vii-端口绑定"><a href="https://www.12factor.net/zh_cn/port-binding">VII. 端口绑定</a></h4>
<p>通过端口绑定提供服务</p>
<h4 id="viii-并发"><a href="https://www.12factor.net/zh_cn/concurrency">VIII. 并发</a></h4>
<p>通过进程模型进行扩展</p>
<h4 id="ix-易处理"><a href="https://www.12factor.net/zh_cn/disposability">IX. 易处理</a></h4>
<p>快速启动和优雅终止可最大化健壮性</p>
<h4 id="x-开发环境与线上环境等价"><a href="https://www.12factor.net/zh_cn/dev-prod-parity">X. 开发环境与线上环境等价</a></h4>
<p>尽可能的保持开发，预发布，线上环境相同</p>
<h4 id="xi-日志"><a href="https://www.12factor.net/zh_cn/logs">XI. 日志</a></h4>
<p>把日志当作事件流</p>
<h4 id="xii-管理进程"><a href="https://www.12factor.net/zh_cn/admin-processes">XII. 管理进程</a></h4>
<p>后台管理任务当作一次性进程运行</p>
<p>列原则简单，但要和实践相结合才好。</p>
<h3 id="什么样的服务是好服务">什么样的服务是好服务</h3>
<p>作者给出的两个概念是：1、松耦合；2、高内聚。这两个概念也不仅仅是微服务的设计理念，而是所有系统设计的基本要求。</p>
<p>做到松耦合，在修改一个服务的时候就不需要修改另一个服务，这样就能够做到独立部署一个服务而不需要修改系统的其它部分。</p>
<p>做到高内聚，也就能在需要修改一个功能时只需要修改一个服务就能实现需求。</p>
<p>可见，松耦合和高内聚本质上可以达到相同的目标。</p>
<h3 id="不要过早划分服务">不要过早划分服务</h3>
<p>在服务有明确的边界之前，最好不要划分服务。毕竟拆分服务比把服务合并起来更容易一些。当一个服务业务边界逐渐明确时，再根据业务边界逐步拆分服务。</p>
<p>对于单个大服务的分解，也建议从分解数据库开始，将杂乱的依赖理清。</p>
<h3 id="服务的集成">服务的集成</h3>
<p>多个服务的集成有多种方式，比如共享数据库、REST调用、远程过程调用。同时服务间调用也有同步调用和异步调用两种方式。这两种方式各有各的好处，不同场景可能需要选择不同的调用方式。</p>
<p>如果使用同步服务，发起一个调用后调用方会阻塞自己并等待整个操作的完成；如果使用异步通信，调用方不需要等待操作完成后就可以返回，甚至可能不需要关心这个操作是否完成。采用异步的方式就需要保证异步调用的可靠性（比如失败了怎么处理，异步任务需要保证幂等）。</p>
<h3 id="服务部署">服务部署</h3>
<p>服务拆分后，服务的数量可能会是原来的几倍、几十倍，可能一个需求的改动会设计几个或者更多的服务部署，这时服务的部署就会变成一个无法避免的问题。一个比较好的做法是将持续集成映射到服务，在代码修改后通过配置自动部署。这里有一个需要注意的点就是可能需要对不同的服务定制化不同的镜像，docker是一个很好的选择。</p>
<h3 id="测试">测试</h3>
<p>《敏捷软件测试》一书曾把测试分为以下四个象限。</p>
<figure data-type="image" tabindex="2"><img src="http://media.gusibi.mobi/F3T-K3q0Y0Ncv10AZyODaMFBHaGj1F4DHL84CMGX4stcm_2p0VB-Y2y4iE-X5zNe" alt="测试的象限.jpeg" loading="lazy"></figure>
<p>处于象限底部的是面向技术的测试，即那些首先能够帮助开发人员构建系统的测试。这个象限中的测试通常是可以自动化的，比如性能测试和单元测试（关于单元测试可以参考这篇文章《学习单元测试，告别祈祷式编程》【2】https://mp.weixin.qq.com/s/oD96OEv92oX0ypAYLbYFyA）。</p>
<p>处于象限上方的测试则是帮助非技术背景的相关人群，了解系统是如何工作的。这种测试包括象限左上角的大范围、端到端的验收测试，还有象限右上角的由用户来进行的在UAT系统上进行手工验证的探索性测试。</p>
<p>测试是微服务系统的一个关键步骤，如果在微服务系统中还有大量的手工测试，可能让系统稳定运行会变成一个挑战。</p>
<p>《Scrum敏捷软件开发》中提到了测试金字塔的概念，测试金字塔如下所示</p>
<figure data-type="image" tabindex="3"><img src="http://media.gusibi.mobi/48bhFMXZNQ3CGiz3p6lK7SUKBMj-WBgSx1owQG7ccJ7oCyR53hz1yxy7g6Hwkt9_" alt="测试的范围.jpeg" loading="lazy"></figure>
<p>主要由单元测试、服务测试和用户界面测试三层。这张图和上一张象限图有异曲同工的作用，都是将测试分为多个层。</p>
<h3 id="监控">监控</h3>
<p>有过bug修复经验的人都知道，在只有一个服务的时候，监控是相对简单的，遇到问题只需要到服务所在容器或者机器查看错误即可。但如果系统是微服务架构，特别是调用链有多个节点时，定位错误就变成了一个不可能完成的任务。此时，监控工具就变得尤为重要。</p>
<p>日志、全链路追踪工具是一个好的选择。</p>
<h3 id="安全">安全</h3>
<p>对于微服务的安全，完全同意作者的观点</p>
<ol>
<li><strong>不要实现自己的加密算法。不要发明自己的安全协议。</strong></li>
<li><strong>不要实现自己的加密算法。不要发明自己的安全协议。</strong></li>
<li><strong>不要实现自己的加密算法。不要发明自己的安全协议。</strong></li>
</ol>
<p>重要的事情说三遍。</p>
<h3 id="康威定律">康威定律</h3>
<p>梅尔 ·康威于1968年4月在Datamation杂志上发表了一篇名为“How Do Committees Invent”的论文，文中指出：</p>
<p><strong>任何组织在设计一套系统（广义概念上的系统）时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。</strong></p>
<p>这句话被称为康威定律。可以用埃里克 · S．雷蒙德在《新黑客字典》中定义总结：“如果你有四个小组开发一个编译器，那你会得到一个四步编译器。”</p>
<p>比如，如果一个组织的耦合度非常低，其创建的系统的模块化就越好，耦合也越低；组织的耦合度越高，其创建的系统的模块化也越差。</p>
<p>康威定律主要强调系统设计和组织结构不匹配可能会导致危险，这引导组织将服务所有权与团队相匹配。</p>
<h3 id="规模化">规模化</h3>
<p>一旦规模化之后，服务就会不可避免的出现问题，现在没有任何一个服务敢保证自己的服务100%可用， 99.999%可用性 已经是一个了不起的数据（但即使这样当服务超过10w时，也总有一台机器是不可用的）。所以，规模化后，即使你买最好的工具，最昂贵的硬件，也无法避免它们会发生故障的事实。</p>
<p>与其把时间放到如何避免服务出错还不如把时间放到如何快速修复系统上。</p>
<h3 id="cap定理">CAP定理</h3>
<p>分布式系统中有三方面需要彼此权衡：一致性（consistency）、可用性（availability）和分区容忍性（partition tolerance）。具体地说，这个定理告诉我们最多只能保证三个中的两个。</p>
<p>具体参考：阮一峰《CAP 定理的含义》【3】https://ruanyifeng.com/blog/2018/07/cap.html</p>
<h3 id="其它有意思的事情">其它有意思的事情</h3>
<p>“两个披萨团队”（没有一个团队应该大到两个比萨不够吃）。</p>
<p>如果不知道怎么拆分微服务，就先构建单个服务吧。</p>
<h3 id="总结">总结</h3>
<figure data-type="image" tabindex="4"><img src="http://media.gusibi.mobi/ClNFWVAh-uvMAYNfA-KHgoqvQW0ati71dUxJTcT8uocm4Sm9vglmSPYxXgPGv5cT" alt="微服务的原则.jpeg" loading="lazy"></figure>
<p>不要实现自己的加密算法库。也不应该实现自己的分布式协调系统。使用已有的可工作的选择是非常明智的。</p>
<h3 id="参考链接">参考链接</h3>
<ul>
<li>【1】https://www.12factor.net/zh_cn/</li>
<li>【2】《学习单元测试，告别祈祷式编程》【https://mp.weixin.qq.com/s/oD96OEv92oX0ypAYLbYFyA</li>
<li>【3】《CAP 定理的含义》https://ruanyifeng.com/blog/2018/07/cap.html</li>
</ul>
<p><strong>最后，感谢女朋友支持和包容，比❤️</strong></p>
<p>也可以在公号输入以下关键字获取历史文章：<code>公号&amp;小程序</code> | <code>设计模式</code> | <code>并发&amp;协程</code></p>
<figure data-type="image" tabindex="5"><img src="http://media.gusibi.mobi/WDz3v4cU4LQq1oyKX-fYK1LxIThzZ1hK931ZaPRC8CdcB0t2oTYJciMDuAws70FY" alt="扫码关注" loading="lazy"></figure>
<hr>
<h3 id="内推时间">内推时间</h3>
<figure data-type="image" tabindex="6"><img src="http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf" alt="" loading="lazy"></figure>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E9%98%85%E8%AF%BB%E7%9A%84%E7%9B%AE%E7%9A%84">📖阅读的目的</a></li>
<li><a href="#%EF%B8%8F%E6%9C%AC%E4%B9%A6%E7%9A%84%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6">⚓️本书的整体框架</a></li>
<li><a href="#%E6%9C%AC%E4%B9%A6%E7%9A%84%E7%9B%AE%E5%BD%95">本书的目录</a></li>
<li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%B9%89">微服务定义</a></li>
<li><a href="#%E6%9E%B6%E6%9E%84%E5%B8%88">架构师</a></li>
<li><a href="#%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99">指导原则</a>
<ul>
<li><a href="#i-%E5%9F%BA%E5%87%86%E4%BB%A3%E7%A0%81">I. 基准代码</a></li>
<li><a href="#ii-%E4%BE%9D%E8%B5%96">II. 依赖</a></li>
<li><a href="#iii-%E9%85%8D%E7%BD%AE">III. 配置</a></li>
<li><a href="#iv-%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1">IV. 后端服务</a></li>
<li><a href="#v-%E6%9E%84%E5%BB%BA%E5%8F%91%E5%B8%83%E8%BF%90%E8%A1%8C">V. 构建，发布，运行</a></li>
<li><a href="#vi-%E8%BF%9B%E7%A8%8B">VI. 进程</a></li>
<li><a href="#vii-%E7%AB%AF%E5%8F%A3%E7%BB%91%E5%AE%9A">VII. 端口绑定</a></li>
<li><a href="#viii-%E5%B9%B6%E5%8F%91">VIII. 并发</a></li>
<li><a href="#ix-%E6%98%93%E5%A4%84%E7%90%86">IX. 易处理</a></li>
<li><a href="#x-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E7%BA%BF%E4%B8%8A%E7%8E%AF%E5%A2%83%E7%AD%89%E4%BB%B7">X. 开发环境与线上环境等价</a></li>
<li><a href="#xi-%E6%97%A5%E5%BF%97">XI. 日志</a></li>
<li><a href="#xii-%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B">XII. 管理进程</a></li>
</ul>
</li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%98%AF%E5%A5%BD%E6%9C%8D%E5%8A%A1">什么样的服务是好服务</a></li>
<li><a href="#%E4%B8%8D%E8%A6%81%E8%BF%87%E6%97%A9%E5%88%92%E5%88%86%E6%9C%8D%E5%8A%A1">不要过早划分服务</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%9B%86%E6%88%90">服务的集成</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2">服务部署</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95">测试</a></li>
<li><a href="#%E7%9B%91%E6%8E%A7">监控</a></li>
<li><a href="#%E5%AE%89%E5%85%A8">安全</a></li>
<li><a href="#%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B">康威定律</a></li>
<li><a href="#%E8%A7%84%E6%A8%A1%E5%8C%96">规模化</a></li>
<li><a href="#cap%E5%AE%9A%E7%90%86">CAP定理</a></li>
<li><a href="#%E5%85%B6%E5%AE%83%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%BA%8B%E6%83%85">其它有意思的事情</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>
<li><a href="#%E5%86%85%E6%8E%A8%E6%97%B6%E9%97%B4">内推时间</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="http://blog.gusibi.site/post/flutter-01-first-demo/">
              <h3 class="post-title">
                Flutter 简明教程：从零创建一个flutter 项目
              </h3>
            </a>
          </div>
        

        
          

          
            <link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css">
<script src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>

<div id="disqus_thread"></div>

<script>

var options = {
  shortname: 'gu-si-bi',
  apikey: '',
}
if ('') {
  options.api = ''
}
var dsqjs = new DisqusJS(options)

</script>

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="http://blog.gusibi.site/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
