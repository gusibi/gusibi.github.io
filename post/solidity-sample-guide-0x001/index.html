<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Solidity 简易教程0x001 | 顾斯比</title>
<link rel="shortcut icon" href="http://blog.gusibi.site/favicon.ico?v=1597591641172">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="http://blog.gusibi.site/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Solidity 简易教程0x001 | 顾斯比 - Atom Feed" href="http://blog.gusibi.site/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-76238744-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-76238744-1');
</script>


    <meta name="description" content="
Solidity是以太坊的主要编程语言，它是一种静态类型的 JavaScript-esque 语言，是面向合约的、为实现智能合约而创建的高级编程语言，设计的目的是能在以太坊虚拟机（EVM）上运行。
本文基于CryptoZombies，教程..." />
    <meta name="keywords" content="tutorial,区块链,以太坊" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="http://blog.gusibi.site">
  <img class="avatar" src="http://blog.gusibi.site/images/avatar.png?v=1597591641172" alt="">
  </a>
  <h1 class="site-title">
    顾斯比
  </h1>
  <p class="site-description">
    这个人很懒
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?eb5ce2e96866802764816b111f5a3ffb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/gusibi" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
        <a href="https://twitter.com/amazing_gs" target="_blank">
          <i class="ri-twitter-line"></i>
        </a>
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Solidity 简易教程0x001
            </h2>
            <div class="post-info">
              <span>
                2018-10-22
              </span>
              <span>
                21 min read
              </span>
              
                <a href="http://blog.gusibi.site/tag/JjoHj10VdB/" class="post-tag">
                  # tutorial
                </a>
              
                <a href="http://blog.gusibi.site/tag/Sgmw7chWDE4/" class="post-tag">
                  # 区块链
                </a>
              
                <a href="http://blog.gusibi.site/tag/i90rYuTuM7C/" class="post-tag">
                  # 以太坊
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <blockquote>
<p>Solidity是以太坊的主要编程语言，它是一种静态类型的 JavaScript-esque 语言，是面向合约的、为实现智能合约而创建的高级编程语言，设计的目的是能在以太坊虚拟机（EVM）上运行。</p>
<p><code>本文基于CryptoZombies，教程地址为：https://cryptozombies.io/zh/lesson/2</code></p>
</blockquote>
<h3 id="地址address">地址（address）</h3>
<p>以太坊区块链由 account (账户)组成，你可以把它想象成银行账户。一个帐户的余额是以太 （在以太坊区块链上使用的币种），你可以和其他帐户之间支付和接受以太币，就像你的银行帐户可以电汇资金到其他银行帐户一样。</p>
<p>每个帐户都有一个“地址”，你可以把它想象成银行账号。这是账户唯一的标识符，它看起来长这样：</p>
<pre><code>0x0cE446255506E92DF41614C46F1d6df9Cc969183
</code></pre>
<blockquote>
<p>这是 CryptoZombies 团队的地址，为了表示支持CryptoZombies，可以赞赏一些以太币！</p>
</blockquote>
<p><code>address</code>：地址类型存储一个 20 字节的值（以太坊地址的大小）。 地址类型也有成员变量，并作为所有合约的基础。</p>
<blockquote>
<p><code>address</code> 类型是一个160位的值，且不允许任何算数操作。这种类型适合存储合约地址或外部人员的密钥对。</p>
</blockquote>
<h3 id="映射mapping">映射（mapping）</h3>
<blockquote>
<p>Mappings 和<a href="https://en.wikipedia.org/wiki/Hash_table">哈希表</a>类似，它会执行虚拟初始化，以使所有可能存在的键都映射到一个字节表示为全零的值。</p>
</blockquote>
<p>映射是这样定义的：</p>
<pre><code class="language-javascript">//对于金融应用程序，将用户的余额保存在一个 uint类型的变量中：
mapping (address =&gt; uint) public accountBalance;
//或者可以用来通过userId 存储/查找的用户名
mapping (uint =&gt; string) userIdToName;
</code></pre>
<p>映射本质上是存储和查找数据所用的键-值对。在第一个例子中，键是一个 address，值是一个 uint，在第二个例子中，键是一个uint，值是一个 string。</p>
<blockquote>
<p>映射类型在声明时的形式为 mapping(_KeyType =&gt; _ValueType)。 其中 _KeyType 可以是除了映射、变长数组、合约、枚举以及结构体以外的几乎所有类型。 _ValueType 可以是包括映射类型在内的任何类型。</p>
</blockquote>
<p>对映射的取值操作如下：</p>
<pre><code class="language-javascript">userIdToName[12]
// 如果键12 不在 映射中，得到的结果是0
</code></pre>
<blockquote>
<p>映射中，实际上并不存储 key，而是存储它的 keccak256 哈希值，从而便于查询实际的值。所以<strong>映射是没有长度的，也没有 key 的集合或 value 的集合的概念。</strong>，你不能像操作<code>python</code>字典那应该获取到当前 Mappings 的所有键或者值。</p>
</blockquote>
<h3 id="特殊变量">特殊变量</h3>
<p>在 Solidity 中，在全局命名空间中已经存在了（预设了）一些特殊的变量和函数，他们主要用来提供关于区块链的信息或一些通用的工具函数。</p>
<h4 id="msgsender">msg.sender</h4>
<p>msg.sender指的是当前调用者（或智能合约）的 address。</p>
<blockquote>
<p>注意：在 Solidity 中，功能执行始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以对于每一个<strong>外部函数</strong>调用，包括 msg.sender 和 msg.value 在内所有 msg 成员的值都会变化。这里包括对库函数的调用。</p>
</blockquote>
<p>以下是使用 msg.sender 来更新 mapping 的例子：</p>
<pre><code class="language-javascript">mapping (address =&gt; uint) favoriteNumber;

function setMyNumber(uint _myNumber) public {
  // 更新我们的 `favoriteNumber` 映射来将 `_myNumber`存储在 `msg.sender`名下
  favoriteNumber[msg.sender] = _myNumber;
  // 存储数据至映射的方法和将数据存储在数组相似
}

function whatIsMyNumber() public view returns (uint) {
  // 拿到存储在调用者地址名下的值
  // 若调用者还没调用 setMyNumber， 则值为 `0`
  return favoriteNumber[msg.sender];
}
</code></pre>
<p>在这个小小的例子中，任何人都可以调用 setMyNumber 在我们的合约中存下一个 uint 并且与他们的地址相绑定。 然后，他们调用 whatIsMyNumber 就会返回他们存储的 uint。</p>
<p>使用 msg.sender 很安全，因为它具有以太坊区块链的安全保障 —— 除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人的数据的。</p>
<p>以下是其它的一些特殊变量。</p>
<h4 id="区块和交易属性">区块和交易属性</h4>
<ul>
<li>block.blockhash(uint blockNumber) returns (bytes32)：指定区块的区块哈希——仅可用于最新的 256 个区块且不包括当前区块；而 blocks 从 0.4.22 版本开始已经不推荐使用，由 blockhash(uint blockNumber) 代替</li>
<li>block.coinbase (address): 挖出当前区块的矿工地址</li>
<li>block.difficulty (uint): 当前区块难度</li>
<li>block.gaslimit (uint): 当前区块 gas 限额</li>
<li>block.number (uint): 当前区块号</li>
<li>block.timestamp (uint): 自 unix epoch 起始当前区块以秒计的时间戳</li>
<li>gasleft() returns (uint256)：剩余的 gas</li>
<li>msg.data (bytes): 完整的 calldata</li>
<li>msg.gas (uint): 剩余 gas - 自 0.4.21 版本开始已经不推荐使用，由 gesleft() 代替</li>
<li>msg.sender (address): 消息发送者（当前调用）</li>
<li>msg.sig (bytes4): calldata 的前 4 字节（也就是函数标识符）</li>
<li>msg.value (uint): 随消息发送的 wei 的数量</li>
<li>now (uint): 目前区块时间戳（block.timestamp）</li>
<li>tx.gasprice (uint): 交易的 gas 价格</li>
<li>tx.origin (address): 交易发起者（完全的调用链）</li>
</ul>
<h3 id="错误处理">错误处理</h3>
<p>Solidity 使用状态恢复异常来处理错误。这种异常将撤消对当前调用（及其所有子调用）中的状态所做的所有更改，并且还向调用者标记错误。</p>
<p>函数 <code>assert</code> 和 <code>require</code> 可用于检查条件并在条件不满足时抛出异常。</p>
<ul>
<li>assert 函数只能用于测试内部错误，并检查非变量。</li>
<li>require 函数用于确认条件有效性，例如输入变量，或合约状态变量是否满足条件，或验证外部合约调用返回的值。</li>
</ul>
<p>这里主要介绍 <code>require</code></p>
<p>require使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行：</p>
<pre><code class="language-javascript">function sayHiToVitalik(string _name) public returns (string) {
  // 比较 _name 是否等于 &quot;Vitalik&quot;. 如果不成立，抛出异常并终止程序
  // (敲黑板: Solidity 并不支持原生的字符串比较, 我们只能通过比较
  // 两字符串的 keccak256 哈希值来进行判断)
  require(keccak256(_name) == keccak256(&quot;Vitalik&quot;));
  // 如果返回 true, 运行如下语句
  return &quot;Hi!&quot;;
}
</code></pre>
<p>如果你这样调用函数 <code>sayHiToVitalik(&quot;Vitalik&quot;)</code> ,它会返回“Hi！”。而如果调用的时候使用了其他参数，它则会抛出错误并停止执行。</p>
<p>因此，在调用一个函数之前，用 require 验证前置条件是非常有必要的。</p>
<blockquote>
<p>注意：在 Solidity 中，关键词放置的顺序并不重要</p>
</blockquote>
<pre><code class="language-javascript">// 以下两个语句等效
require(keccak256(_name) == keccak256(&quot;Vitalik&quot;));
require(keccak256(&quot;Vitalik&quot;) == keccak256(_name));
</code></pre>
<h3 id="外内部函数">外/内部函数</h3>
<p>除 public 和 private 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：internal（内部） 和 external（外部）。</p>
<p><code>internal</code> 和 <code>private</code> 类似，不过，如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的<code>“内部(internal)”函数</code>。</p>
<p><code>external</code> 与<code>public</code> 类似，只不过<code>external</code>函数只能在合约之外调用 - 它们不能被合约内的其他函数调用。</p>
<p>声明函数 internal 或 external 类型的语法，与声明 private 和 public类 型相同：</p>
<pre><code class="language-javascript">contract Sandwich {
  uint private sandwichesEaten = 0;

  function eat() internal {
    sandwichesEaten++;
  }
}

contract BLT is Sandwich {
  uint private baconSandwichesEaten = 0;

  function eatWithBacon() public returns (string) {
    baconSandwichesEaten++;
    // 因为eat() 是internal 的，所以我们能在这里调用
    eat();
  }
}
</code></pre>
<p>Solidity 有两种函数调用（内部调用不会产生实际的 EVM 调用或称为<code>消息调用</code>，而外部调用则会产生一个 EVM 调用）， 函数和状态变量有四种可见性类型。 函数可以指定为 external ，public ，internal 或者 private，默认情况下函数类型为 public。 对于状态变量，不能设置为 external ，默认是 internal 。</p>
<ul>
<li>
<p><code>external ：</code><br>
外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 f 不能从内部调用（即 f 不起作用，但 this.f() 可以）。 当收到大量数据的时候，外部函数有时候会更有效率。</p>
</li>
<li>
<p><code>public ：</code><br>
public 函数是合约接口的一部分，可以在内部或通过消息调用。对于公共状态变量， 会自动生成一个 getter 函数。</p>
</li>
<li>
<p><code>internal ：</code><br>
这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 this 调用。</p>
</li>
<li>
<p><code>private ：</code><br>
private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。</p>
</li>
</ul>
<blockquote>
<p>合约中的所有内容对外部观察者都是可见的。设置一些 private 类型只能阻止其他合约访问和修改这些信息， 但是对于区块链外的整个世界它仍然是可见的。</p>
</blockquote>
<p>可见性标识符的定义位置，对于状态变量来说是在类型后面，对于函数是在参数列表和返回关键字中间。</p>
<pre><code class="language-javascript">pragma solidity ^0.4.16;

contract C {
    // 对于函数是在参数列表和返回关键字中间。
    function f(uint a) private pure returns (uint b) { return a + 1; }
    function setData(uint a) internal { data = a; }
    uint public data;  // 对于状态变量来说是在类型后面
}
</code></pre>
<h3 id="函数多值返回">函数多值返回</h3>
<p>和 python 类似，Solidity 函数支持多值返回，比如：</p>
<pre><code class="language-javascript">
function multipleReturns() internal returns(uint a, uint b, uint c) {
  return (1, 2, 3);
}

function processMultipleReturns() external {
  uint a;
  uint b;
  uint c;
  // 这样来做批量赋值:
  (a, b, c) = multipleReturns();
}

// 或者如果我们只想返回其中一个变量:
function getLastReturnValue() external {
  uint c;
  // 可以对其他字段留空:
  (,,c) = multipleReturns();
}

</code></pre>
<blockquote>
<p>这里留空字段使用<code>,</code>的方式太不直观了，还不如 python/go 使用下划线<code>_</code>代替无用字段。</p>
</blockquote>
<h3 id="storage与memory">Storage与Memory</h3>
<p>在 Solidity 中，有两个地方可以存储变量 —— storage 或 memory。</p>
<p>Storage 变量是指永久存储在区块链中的变量。 Memory 变量则是临时的，当外部函数对某合约调用完成时，内存型变量即被移除。 你可以把它想象成存储在你电脑的硬盘或是RAM中数据的关系。</p>
<blockquote>
<p>storage 和 memory 放到状态变量名前边，在类型后边，格式如下：<br>
<code>变量类型 &lt;storage|memory&gt; 变量名</code></p>
</blockquote>
<p>大多数时候都用不到这些关键字，默认情况下 Solidity 会自动处理它们。 状态变量（在函数之外声明的变量）默认为“存储”形式，并永久写入区块链；而在函数内部声明的变量是“内存”型的，它们函数调用结束后消失。</p>
<p>然而也有一些情况下，你需要手动声明存储类型，主要用于处理函数内的 <code>结构体</code> 和 <code>数组</code> 时：</p>
<pre><code class="language-javascript">contract SandwichFactory {
  struct Sandwich {
    string name;
    string status;
  }

  Sandwich[] sandwiches;

  function eatSandwich(uint _index) public {
    // Sandwich mySandwich = sandwiches[_index];

    // ^ 看上去很直接，不过 Solidity 将会给出警告
    // 告诉你应该明确在这里定义 `storage` 或者 `memory`。

    // 所以你应该明确定义 `storage`:
    Sandwich storage mySandwich = sandwiches[_index];
    // ...这样 `mySandwich` 是指向 `sandwiches[_index]`的指针
    // 在存储里，另外...
    mySandwich.status = &quot;Eaten!&quot;;
    // ...这将永久把 `sandwiches[_index]` 变为区块链上的存储

    // 如果你只想要一个副本，可以使用`memory`:
    Sandwich memory anotherSandwich = sandwiches[_index + 1];
    // ...这样 `anotherSandwich` 就仅仅是一个内存里的副本了
    // 另外
    anotherSandwich.status = &quot;Eaten!&quot;;
    // ...将仅仅修改临时变量，对 `sandwiches[_index + 1]` 没有任何影响
    // 不过你可以这样做:
    sandwiches[_index + 1] = anotherSandwich;
    // ...如果你想把副本的改动保存回区块链存储
  }
}
</code></pre>
<p>如果你还没有完全理解究竟应该使用哪一个，也不用担心 —— 在本教程中，我们将告诉你何时使用 storage 或是 memory，并且当你不得不使用到这些关键字的时候，Solidity 编译器也发警示提醒你的。</p>
<p>现在，只要知道在某些场合下也需要你显式地声明 storage 或 memory就够了！</p>
<h3 id="继承">继承</h3>
<p>Solidity 的继承和 Python 的继承相似，支持多重继承。<br>
看下面这个例子：</p>
<pre><code class="language-javascript">contract Doge {
  function catchphrase() public returns (string) {
    return &quot;So Wow CryptoDoge&quot;;
  }
}

contract BabyDoge is Doge {
  function anotherCatchphrase() public returns (string) {
    return &quot;Such Moon BabyDoge&quot;;
  }
}

// 可以多重继承。请注意，Doge 也是 BabyDoge 的基类，
// 但只有一个 Doge 实例（就像 C++ 中的虚拟继承）。
contract BlackBabyDoge is Doge, BabyDoge {
  function color() public returns (string) {
    return &quot;Black&quot;;
  }
}

</code></pre>
<p><code>BabyDoge</code> 从 <code>Doge</code> 那里 <code>inherits（继承)</code>过来。 这意味着当编译和部署了 <code>BabyDoge</code>，它将可以访问 catchphrase() 和 anotherCatchphrase()和其他我们在 Doge 中定义的其他公共函数（private 函数不可访问）。</p>
<p>Solidity使用 is 从另一个合约派生。派生合约可以访问所有非私有成员，包括内部函数和状态变量，但无法通过 <code>this</code> 来外部访问。</p>
<h4 id="基类构造函数的参数">基类构造函数的参数</h4>
<p>派生合约需要提供基类构造函数需要的所有参数。这可以通过两种方式来完成:</p>
<pre><code class="language-javascript">pragma solidity ^0.4.0;

contract Base {
    uint x;
    // 这是注册 Base 和设置名称的构造函数。
    function Base(uint _x) public { x = _x; }
}

contract Derived is Base(7) {
    function Derived(uint _y) Base(_y * _y) public {
    }
}

contract Derived1 is Base {
    function Derived1(uint _y) Base(_y * _y) public {
    }
}
</code></pre>
<p>一种方法直接在继承列表中调用基类构造函数（<code>is Base(7)</code>）。 另一种方法是像 <code>修饰器 modifier</code> 使用方法一样， 作为派生合约构造函数定义头的一部分，（<code>Base(_y * _y)</code>)。 如果构造函数参数是常量并且定义或描述了合约的行为，使用第一种方法比较方便。 如果基类构造函数的参数依赖于派生合约，那么必须使用第二种方法。 如果像这个简单的例子一样，两个地方都用到了，优先使用 修饰器modifier 风格的参数。</p>
<h3 id="抽象合约">抽象合约</h3>
<p>合约函数可以缺少实现，如下例所示（请注意函数声明头由 <strong>;</strong> 结尾）:</p>
<pre><code class="language-javascript">pragma solidity ^0.4.0;

contract Feline {
    function utterance() public returns (bytes32);
}
</code></pre>
<p>这些合约无法成功编译（即使它们除了未实现的函数还包含其他已经实现了的函数），但他们可以用作基类合约:</p>
<pre><code class="language-javascript">pragma solidity ^0.4.0;

contract Feline {
    function utterance() public returns (bytes32);
}

contract Cat is Feline {
    function utterance() public returns (bytes32) { return &quot;miaow&quot;; }
}
</code></pre>
<p>如果合约继承自抽象合约，并且没有通过重写来实现所有未实现的函数，那么它本身就是抽象的。</p>
<h3 id="接口interface">接口（Interface）</h3>
<p>接口类似于抽象合约，但是它们不能实现任何函数。还有进一步的限制：</p>
<ul>
<li>无法继承其他合约或接口。</li>
<li>无法定义构造函数。</li>
<li>无法定义变量。</li>
<li>无法定义结构体</li>
<li>无法定义枚举。</li>
</ul>
<p>首先，看一下一个interface的例子：</p>
<pre><code class="language-javascript">
contract NumberInterface {
  function getNum(address _myAddress) public view returns (uint);
}
</code></pre>
<p>请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同：</p>
<ul>
<li>首先，只声明了要与之交互的函数 —— 在本例中为 getNum —— 在其中没有使用到任何其他的函数或状态变量。</li>
<li>其次，并没有使用大括号（{ 和 }）定义函数体，单单用分号（<code>;</code>）结束了函数声明。这使它看起来像一个合约框架。</li>
</ul>
<p>编译器就是靠这些特征认出它是一个接口的。</p>
<blockquote>
<p>就像继承其他合约一样，合约可以继承接口。</p>
</blockquote>
<p>可以在合约中这样使用接口：</p>
<pre><code class="language-javascript">contract MyContract {
  address NumberInterfaceAddress = 0xab38...;
  // ^ 这是FavoriteNumber合约在以太坊上的地址
  NumberInterface numberContract = NumberInterface(NumberInterfaceAddress);
  // 现在变量 `numberContract` 指向另一个合约对象

  function someFunction() public {
    // 现在我们可以调用在那个合约中声明的 `getNum`函数:
    uint num = numberContract.getNum(msg.sender);
    // ...在这儿使用 `num`变量做些什么
  }
}
</code></pre>
<p>通过这种方式，只要将合约的可见性设置为<code>public</code>(公共)或<code>external</code>(外部)，它们就可以与以太坊区块链上的任何其他合约进行交互。</p>
<h3 id="与其他合约的交互">与其他合约的交互</h3>
<p>如果一个合约需要和区块链上的其他的合约会话，则需先定义一个 interface (接口)。</p>
<p>先举一个简单的栗子。 假设在区块链上有这么一个合约：</p>
<pre><code class="language-javascript">contract LuckyNumber {
  mapping(address =&gt; uint) numbers;

  function setNum(uint _num) public {
    numbers[msg.sender] = _num;
  }

  function getNum(address _myAddress) public view returns (uint) {
    return numbers[_myAddress];
  }
}
</code></pre>
<p>这是个很简单的合约，可以用它存储自己的幸运号码，并将其与调用者的以太坊地址关联。 这样其他人就可以通过地址查找幸运号码了。</p>
<p>现在假设我们有一个外部合约，使用 getNum 函数可读取其中的数据。</p>
<p>首先，我们定义 LuckyNumber 合约的 interface ：</p>
<pre><code class="language-javascript">
contract NumberInterface {
  function getNum(address _myAddress) public view returns (uint);
}
</code></pre>
<p>使用这个接口，合约就知道其他合约的函数是怎样的，应该如何调用，以及可期待什么类型的返回值。</p>
<p>下面是一个示例代码，会用到上边的知识点：</p>
<pre><code class="language-javascript">pragma solidity ^0.4.19;

contract ZombieFactory {

    event NewZombie(uint zombieId, string name, uint dna);

    uint dnaDigits = 16;
    uint dnaModulus = 10 ** dnaDigits;

    struct Zombie {
        string name;
        uint dna;
    }

    Zombie[] public zombies;

    // 创建一个叫做 zombieToOwner 的映射。其键是一个uint，值为 address。映射属性为public
    mapping (uint =&gt; address) public zombieToOwner;
    // 创建一个名为 ownerZombieCount 的映射，其中键是 address，值是 uint
    mapping (address =&gt; uint) ownerZombieCount;

    function _createZombie(string _name, uint _dna) private {
        uint id = zombies.push(Zombie(_name, _dna)) - 1;
        zombieToOwner[id] = msg.sender;
        ownerZombieCount[msg.sender]++;
        NewZombie(id, _name, _dna);
    }

    function _generateRandomDna(string _str) private view returns (uint) {
        uint rand = uint(keccak256(_str));
        return rand % dnaModulus;
    }

    function createRandomZombie(string _name) public {
        // 我们使用了 require 来确保这个函数只有在每个用户第一次调用它的时候执行，用以创建初始僵尸
        require(ownerZombieCount[msg.sender] == 0);
        uint randDna = _generateRandomDna(_name);
        _createZombie(_name, randDna);
    }

}

// CryptoKitties 合约提供了getKitty 函数，它返回所有的加密猫的数据，包括它的“基因”（僵尸游戏要用它生成新的僵尸）。
// 一个获取 kitty 的接口
contract KittyInterface {
  
  // 在interface里定义了 getKitty 函数 在 returns 语句之后用分号
  function getKitty(uint256 _id) external view returns (
    bool isGestating,
    bool isReady,
    uint256 cooldownIndex,
    uint256 nextActionAt,
    uint256 siringWithId,
    uint256 birthTime,
    uint256 matronId,
    uint256 sireId,
    uint256 generation,
    uint256 genes
  );
}

//ZombieFeeding继承自 `ZombieFactory 合约
contract ZombieFeeding is ZombieFactory {
  
  // CryptoKitties 合约的地址
  address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
  // 创建一个名为 kittyContract 的 KittyInterface，并用 ckAddress 为它初始化 
  KittyInterface kittyContract = KittyInterface(ckAddress);
  
  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public {
      // 确保对自己僵尸的所有权
      require(msg.sender == zombieToOwner[_zombieId]);
      // 声明一个名为 myZombie 数据类型为Zombie的 storage 类型本地变量
      Zombie storage myZombie = zombies[_zombieId];
      _targetDna = _targetDna % dnaModulus;
      uint newDna = (myZombie.dna + _targetDna) / 2;
      // Add an if statement here
      if (keccak256(_species) == keccak256(&quot;kitty&quot;)){
          newDna = newDna - newDna％100 + 99;
      }
      _createZombie(&quot;NoName&quot;, newDna);
  }
  
  function feedOnKitty(uint _zombieId, uint _kittyId) public {
    uint kittyDna;
    // 多值返回，这里只需要最后一个值
    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
    feedAndMultiply(_zombieId, kittyDna, &quot;kitty&quot;);
  }
}

</code></pre>
<blockquote>
<p>这段代码看起来内容有点多，可以拆分一下，把 <code>ZombieFactory</code>代码提取到一个新的文件<code>zombiefactory.sol</code>，现在就可以使用 import 语句来导入另一个文件的代码。</p>
</blockquote>
<h3 id="import">import</h3>
<p>在 Solidity 中，当你有多个文件并且想把一个文件导入另一个文件时，可以使用 import 语句：</p>
<pre><code class="language-javascript">
import &quot;./someothercontract.sol&quot;;

contract newContract is SomeOtherContract {

}
</code></pre>
<p>这样当我们在合约（contract）目录下有一个名为 someothercontract.sol 的文件（ ./ 就是同一目录的意思），它就会被编译器导入。</p>
<blockquote>
<p>这一点和 go 类似，在同一目录下文件中的内容可以直接使用，而不用使用 <strong>xxx.name</strong> 的形式。</p>
</blockquote>
<h3 id="测试调用">测试调用</h3>
<p>编译和部署 ZombieFeeding，就可以将这个合约部署到以太坊了。最终完成的这个合约继承自 ZombieFactory，因此它可以访问自己和父辈合约中的所有 public 方法。</p>
<p>下面是一个与ZombieFeeding合约进行交互的例子， 这个例子使用了 JavaScript 和 web3.js：</p>
<pre><code class="language-javascript">var abi = /* abi generated by the compiler */
var ZombieFeedingContract = web3.eth.contract(abi)
var contractAddress = /* our contract address on Ethereum after deploying */
var ZombieFeeding = ZombieFeedingContract.at(contractAddress)

// 假设我们有我们的僵尸ID和要攻击的猫咪ID
let zombieId = 1;
let kittyId = 1;

// 要拿到猫咪的DNA，我们需要调用它的API。这些数据保存在它们的服务器上而不是区块链上。
// 如果一切都在区块链上，我们就不用担心它们的服务器挂了，或者它们修改了API，
// 或者因为不喜欢我们的僵尸游戏而封杀了我们
let apiUrl = &quot;https://api.cryptokitties.co/kitties/&quot; + kittyId
$.get(apiUrl, function(data) {
  let imgUrl = data.image_url
  // 一些显示图片的代码
})

// 当用户点击一只猫咪的时候:
$(&quot;.kittyImage&quot;).click(function(e) {
  // 调用我们合约的 `feedOnKitty` 函数
  ZombieFeeding.feedOnKitty(zombieId, kittyId)
})

// 侦听来自我们合约的新僵尸事件好来处理
ZombieFactory.NewZombie(function(error, result) {
  if (error) return
  // 这个函数用来显示僵尸:
  generateZombie(result.zombieId, result.name, result.dna)
})
</code></pre>
<h3 id="参考链接">参考链接</h3>
<ul>
<li><a href="https://solidity-cn.readthedocs.io/zh/develop/index.html">Solidity 文档：https://solidity-cn.readthedocs.io/zh/develop/index.html</a></li>
<li><a href="https://cryptozombies.io/zh/lesson/2">cryptozombie-lessons2 僵尸攻击人类：https://cryptozombies.io/zh/lesson/2</a></li>
<li><a href="https://mp.weixin.qq.com/s/1MaIc7uNqBMx-_eO4WGQgA">Solidity 简易教程</a></li>
</ul>
<hr>
<p><strong>最后，感谢女朋友支持和包容，比❤️</strong></p>
<p>也可以在公号输入以下关键字获取历史文章：<code>公号&amp;小程序</code> | <code>设计模式</code> | <code>并发&amp;协程</code></p>
<figure data-type="image" tabindex="1"><img src="http://media.gusibi.mobi/ah0mqMXMtdJb9Yj03suu-NGEyVRxyEuOIT5bXSv7ip5aqtHkiRjTTl8SMRMv3Qp5" alt="" loading="lazy"></figure>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E5%9C%B0%E5%9D%80address">地址（address）</a></li>
<li><a href="#%E6%98%A0%E5%B0%84mapping">映射（mapping）</a></li>
<li><a href="#%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F">特殊变量</a>
<ul>
<li><a href="#msgsender">msg.sender</a></li>
<li><a href="#%E5%8C%BA%E5%9D%97%E5%92%8C%E4%BA%A4%E6%98%93%E5%B1%9E%E6%80%A7">区块和交易属性</a></li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a></li>
<li><a href="#%E5%A4%96%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0">外/内部函数</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%A4%9A%E5%80%BC%E8%BF%94%E5%9B%9E">函数多值返回</a></li>
<li><a href="#storage%E4%B8%8Ememory">Storage与Memory</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a>
<ul>
<li><a href="#%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0">基类构造函数的参数</a></li>
</ul>
</li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E5%90%88%E7%BA%A6">抽象合约</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3interface">接口（Interface）</a></li>
<li><a href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E5%90%88%E7%BA%A6%E7%9A%84%E4%BA%A4%E4%BA%92">与其他合约的交互</a></li>
<li><a href="#import">import</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E8%B0%83%E7%94%A8">测试调用</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="http://blog.gusibi.site/post/sqlalchemy_in_empty_list_analyze/">
              <h3 class="post-title">
                SQLAlchemy in 空列表问题分析
              </h3>
            </a>
          </div>
        

        
          

          
            <link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css">
<script src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>

<div id="disqus_thread"></div>

<script>

var options = {
  shortname: 'gu-si-bi',
  apikey: '',
}
if ('') {
  options.api = ''
}
var dsqjs = new DisqusJS(options)

</script>

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="http://blog.gusibi.site/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
