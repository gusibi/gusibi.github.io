<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>操作系统发展和进程简介 | 顾斯比</title>
<link rel="shortcut icon" href="http://blog.gusibi.site/favicon.ico?v=1593958763608">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="http://blog.gusibi.site/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="操作系统发展和进程简介 | 顾斯比 - Atom Feed" href="http://blog.gusibi.site/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-76238744-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-76238744-1');
</script>


    <meta name="description" content="
这是操作系统进程系列文章第一篇-操作系统发展和进程简介

操作系统的发展
串行处理
对于早期计算机（20世纪40年代后期到20世纪50年代中期），因为没有操作系统，程序员都是直接与计算机硬件打交道。这些机器都在一个控制台上运行，控制台包括..." />
    <meta name="keywords" content="读书笔记,后端,并发,进程" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="http://blog.gusibi.site">
  <img class="avatar" src="http://blog.gusibi.site/images/avatar.png?v=1593958763608" alt="">
  </a>
  <h1 class="site-title">
    顾斯比
  </h1>
  <p class="site-description">
    这个人很懒
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/gusibi" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
        <a href="https://twitter.com/amazing_gs" target="_blank">
          <i class="ri-twitter-line"></i>
        </a>
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              操作系统发展和进程简介
            </h2>
            <div class="post-info">
              <span>
                2018-03-07
              </span>
              <span>
                12 min read
              </span>
              
                <a href="http://blog.gusibi.site/tag/R03AJFQeGg/" class="post-tag">
                  # 读书笔记
                </a>
              
                <a href="http://blog.gusibi.site/tag/f-Wl7DIwGU/" class="post-tag">
                  # 后端
                </a>
              
                <a href="http://blog.gusibi.site/tag/Y7K-ZUm9XP/" class="post-tag">
                  # 并发
                </a>
              
                <a href="http://blog.gusibi.site/tag/QVdSh7eeOQ5/" class="post-tag">
                  # 进程
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <blockquote>
<p>这是<code>操作系统进程</code>系列文章第一篇-操作系统发展和进程简介</p>
</blockquote>
<h3 id="操作系统的发展">操作系统的发展</h3>
<h4 id="串行处理">串行处理</h4>
<p>对于早期计算机（20世纪40年代后期到20世纪50年代中期），因为没有操作系统，程序员都是直接与计算机硬件打交道。这些机器都在一个控制台上运行，控制台包括显示灯、触发器、某种类型的输入设备和打印机。用机器代码编写的程序通过输入设备载入计算机。如果程序因错误停止，错误原因由指示灯只是。如果程序运行结束，结果将出现在打印机中。</p>
<p><em>早期系统主要有两个问题</em>：</p>
<ul>
<li>调度： 大多数设备使用一个硬拷贝的登记表预定时间。如果用户预定了一个小时，半小时就运行结束，计算机将闲置30分钟，而如果没有在一个小时内运行结束，程序也会被强制停止。</li>
<li>准备时间：一个程序称为一个作业，运行一个程序可能需要往内存中加载编译器和程序语言，保存编译程序，加载目标程序和公用函数变链接在一起。每一步都可能需要安装拆卸硬件，如果这些步骤出现错误，只能重新开始，会占用太多时间。</li>
</ul>
<p>这种模式称为串行处理，用户必须顺序访问计算机。</p>
<h4 id="简单批处理系统">简单批处理系统</h4>
<p>早期计算机非常贵，调度和准备又非常浪费时间和资源，为了最大限度的利用处理器，当时的研究人员开发了批处理操作系统。</p>
<p>第一个批处理操作系统（也是第一个操作系统）是20世纪50年代中期由 General Motors 开发的，用在 IBM 701上。</p>
<p>简单批处理方案的中心思想是使用一个称作<code>监控程序</code>的软件。通过使用这类操作系统，用户不再直接访问机器，相反，用户把卡片或磁带中的作业提交给计算机管理员，由他把这些作业按顺序组织成一批，并将整个批作业放在输入设备上，供监控程序使用。每个程序完成批处理后返回到监控程序，同事监控程序自动加载下一个程序。</p>
<p>我们可以从两个角度分析这个方案是如何工作的：</p>
<p><code>监控程序角度：</code> 监控程序为了能一直控制事件的顺序，需要总是处于内存中并且可以执行。监控程序每次从输入设备中读取一个作业，读入后，当前作业被放置在用户程序区域，并把控制权交给这个作业。作业完成后，控制权交还给监控程序，监控程序再读入下一个作业。</p>
<p><code>处理器角度:</code> 从这个角度看，处理器执行内存中存储的监控程序的指令，这些指令读入下一个作业并存储到内存中的另一个部分。一旦已经读入一个作业，处理器将会遇到监控程序的分支指令，分支指令指导处理器在用户程序开始处继续执行。处理器继而执行用户程序直到执行结束或者遇到错误。无论哪种情况，处理器都将从监控程序读入下一个指令。</p>
<blockquote>
<p><code>控制权交给作业</code>仅仅意味着处理器当前取和执行的都是用户程序中的指令，而<code>控制权交给监控程序</code>的意思是处理器当前从监控程序中取指令并且执行指令。</p>
</blockquote>
<p>监控程序或者批处理操作系统，只是一个简单的计算机程序。它依赖于处理器可以从内存的不同部分取指令的能力，以交替的获取或释放控制权。此外，还要考虑其他硬件功能：</p>
<ul>
<li>内存保护：当用户程序在运行时，不能改变包含监控程序的内存区域</li>
<li>定时器：用户防止一个作业独占系统。作业开始时，设置定时器，时间到，用户程序将被停止</li>
<li>特权指定：某些指令设计成特权指令，只能由监控程序执行。</li>
<li>中断：早期的计算机模型没有中断能力。这个特征使得操作系统在让用户程序放弃控制权或从用户程序获得控制权时具有更大的灵活性。</li>
</ul>
<h4 id="多道程序设计批处理多任务处理系统">多道程序设计批处理（多任务处理）系统</h4>
<p>虽然简单的批处理系统可以提供自动作业序列，但由于 I/O 设备处理速度相对于处理器速度太慢，处理器仍然经常空闲。这个时候多道程序设计/多任务处理方案就被提了出来。</p>
<p>它的工作原理是：基于内存空间可以保存操作系统和一个用户程序，假设内存空间容得下操作系统和两个用户程序，那么当一个作业需要等待 I/O 时，处理器可以切换到另一个可能并不在等待 I/O 的作业。进一步还可以扩展存储器以保存三个、四个或更多的程序，并在它们之间进行切换。</p>
<figure data-type="image" tabindex="1"><img src="http://media.gusibi.mobi/knNY5bDB-SP5Vn1eOwq1QOBnC6F8SfwZD1ZIw94D_Gs4JXBKidmXYsgnHNpvjUOu" alt="多道程序设计实例" loading="lazy"></figure>
<p>多道程序操作系统比单个程序或单道程序系统相对要复杂一些。对准备运行的多个作业，它们必须保存在内存中，这就需要内存管理。此外，如果多个作业都准备运行，处理器还必须决定运行哪一个，这需要某种调度算法。</p>
<p>多道程序设计是为了让处理器和 I/O 设备同时保持忙状态，以实现最大效率。其关键机制是：在响应表示 I/O 事务结束的信号时，操作系统对内存中驻留的不同程序进行处理器切换。</p>
<h4 id="分时系统">分时系统</h4>
<p>通过使用多道程序设计，可以使批处理更加有效，但是对许多作业来说，需要提供一个交互模式，以使用户可以和计算机交互。</p>
<p>因为当时的计算机特别昂贵且巨大，普通用户也买不起，分时操作系统应运而生。</p>
<p>和多道程序设计允许处理器同时处理多个批作业一样，它还可以用于处理多个交互作业。</p>
<blockquote>
<p>多个用户分享处理器的时间，因而该技术成为分时。</p>
</blockquote>
<p>分时系统中，多个用户可以通过终端同时访问系统，由操作系统控制每个用户程序以很短的时间为单位交替执行。</p>
<blockquote>
<p>如果有 n 个用户同时请求服务，若不计算操作系统的开销，每个用户平均只能得到1/n 计算机的有效速度，但由于人的反应时间相对计算机比较慢，所以一个设计良好的操作系统，其响应时间可以接近于计算机的时间。</p>
</blockquote>
<p>批处理多道程序设计和分时的比较</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>批处理多道程序设计</th>
<th>分时</th>
</tr>
</thead>
<tbody>
<tr>
<td>主要目标</td>
<td>充分使用处理器</td>
<td>减小响应时间</td>
</tr>
<tr>
<td>操作系统指令源</td>
<td>作业提供的作业控制语言命令</td>
<td>从终端键入的命令</td>
</tr>
</tbody>
</table>
<blockquote>
<p>第一个分时操作系统是由麻省理工学院开发的兼容分时系统（CTSS）。系统运行在一台内存为32000个36位字的机器上，常驻程序占用了5000个。当控制权被分配给一个交互用户时，改用户的程序和数据被载入到内存剩余的27000个字的空间中。程序通常在第5000个字单元处开始被载入，系统时钟以大约没0.2秒一个的速度产生中断，在每个中断处，操作系统恢复控制权，并将处理器分配给下一个用户。因此，在固定的时间间隔内，当前用户被剥夺，另一个用户被载入。这项技术称为<code>时间片</code>技术。</p>
</blockquote>
<p>操作系统是最复杂的软件之一，操作系统开发中有5个重要的理论进展：<code>进程</code>、<code>内存管理</code>、<code>信息保护和安全</code>、调度和资源管理、系统结构。</p>
<h3 id="进程">进程</h3>
<p>进程的概念是操作系统结构的基础，这个属于最早在20世纪60年代被提出。</p>
<p>关于进程有很多定义：</p>
<ul>
<li>一个正在执行的程序</li>
<li>计算机中正在运行的程序的一个实例</li>
<li>可以分配给处理器并由处理器执行的一个实体</li>
<li>由单一的顺序的执行线程、一个当前状态和一组相关的系统资源所描述的活动单元</li>
</ul>
<p>系统程序员在开发早期的多道程序（多任务）和多用户交互系统时（分时）使用的主要工具是中断。一个已定义事件的发生可以暂停任何作业的活动。处理器保留某些上下文（如程序计数器和其他寄存器），然后跳转到中断处理程序中，处理中断，然后恢复用户被中断作业或其他作业的处理。</p>
<p>设计出一个能够协调各种不同活动的系统软件非常困难，也容易出错，一般而言，产生这类错误又4个主要原因：</p>
<ol>
<li>不正确的同步：常常会出现这样的情况，一个例程必须挂起，等待系统中其他地方的某一事件。</li>
<li>失败的互斥：常常出现多个用户或程序试图同时使用一个共享资源的情况。（例如两个用户同时试图编辑文件）</li>
<li>不正确的程序操作：一个特定的程序结果只依赖与该程序的输入，而并不依赖于共享系统中其他程序的活动。但当程序共享内存并且处理器控制它们交错执行时，它们可能会因为重写相同的内存区域而发生不可预测的相互干扰</li>
<li>死锁：很可能两个或多个程序相互挂起等待。（单进程 web 应用中相互调用）</li>
</ol>
<p>解决这些问题需要一种系统级的方法监控处理器中不同程序的执行。进程的概念为此提供了基础。进程可以看做是由3部分组成的：</p>
<ul>
<li>一段可执行的程序</li>
<li>程序所需的相关数据（变量、工作空间、缓冲区）</li>
<li>程序的执行上下文</li>
</ul>
<p>最后一部分是根本。执行上下文（execution context）又称做进程状态，是操作系统用来管理和控制进程所需的内部数据。</p>
<blockquote>
<p>这种内部信息和进程是分开的，因为操作系统信息不允许被进程之间访问。</p>
</blockquote>
<p>上下文包括操作系统管理进程以及处理器正确执行进程所需的所有信息。包括了各种处理器寄存器的内容，汝程序计数器和数据寄存器。它还包括操作系统使用的信息，如进程优先级以及进程是否在等待特定 I/O 事件的完成。</p>
<p>操作系统会给每个进程（包含程序、数据和上下文信息）分配一块存储器区域，并在由操作系统建立和维护的进程表中进行记录。进程表包含记录每个进程的表项，表项内容包括指向包含进程的存储块地址的指针，还包括该进程的部分或全部执行上下文。</p>
<ul>
<li>进程索引寄存器包含当前正在控制处理器的进程在进程表中的索引。</li>
<li>程序计数器指向该进程中下一条待执行的指令。</li>
<li>基址寄存器和界限寄存器定义了该进程所占的存储器区域：基址寄存器中保存了该存储区域的开始地址，界限寄存器中保存了该区域的大小。</li>
</ul>
<blockquote>
<p>程序计数器和所有的数据引用相对于基址寄存器被解释，并且不能超过界限寄存器中的值，这就可以保护内部进程间不会相互干涉。</p>
</blockquote>
<p>下图是一种进程管理的方法：</p>
<figure data-type="image" tabindex="2"><img src="http://media.gusibi.mobi/v4Sj3T22rYA1gqBWodb7F0cYZf2tf4tt7ISgv4sNnSjEw_j2vw1D6l01uvE-TKOG" alt="典型的进程实现方法" loading="lazy"></figure>
<p>在上图中，进程索引寄存器表明进程 B 正在执行。以前执行的进程被临时中断，在 A 中断的同时，所有寄存器的内容被记录在它的执行上下文环境中，以后操作系统就可以执行进程切换，恢复进程 A 的执行。进程切换过程包括保存 B 的上下文和恢复 A 的上下文。当在程序计数器中载入指向 A 的程序区域的值时，进程 A 自动恢复执行。</p>
<blockquote>
<p>进程是被当做数据结构来实现的，一个进程可以是正在执行，也可以是等待执行。任何时候整个进程状态都包含在它的上下文环境中。</p>
</blockquote>
<p>这一篇主要介绍了操作系统的发展，下篇主要介绍进程的概念以及工作原理。</p>
<hr>
<p><strong>最后，感谢女朋友支持和包容，比❤️</strong></p>
<p>想了解以下内容可以在公号输入相应关键字获取历史文章： <code>公号&amp;小程序</code> | <code>设计模式</code> | <code>并发&amp;协程</code></p>
<table>
<thead>
<tr>
<th>关注</th>
<th>赞赏</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="http://media.gusibi.mobi/kel2L88yf9YXZYecLIn0LPZPSXc7zJfHyGUz5biWsZrGh7xF2JONZT93dgClGdMn" alt="" loading="lazy"></td>
<td><img src="http://media.gusibi.mobi/VFjjmZ7cgkIkpieAFHYXcLVBB8f9snm2vAzc0GyLjSmCzok8mL3vqLNMzYVvrDha" alt="" loading="lazy"></td>
</tr>
</tbody>
</table>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95">操作系统的发展</a>
<ul>
<li><a href="#%E4%B8%B2%E8%A1%8C%E5%A4%84%E7%90%86">串行处理</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F">简单批处理系统</a></li>
<li><a href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%89%B9%E5%A4%84%E7%90%86%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F">多道程序设计批处理（多任务处理）系统</a></li>
<li><a href="#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F">分时系统</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9B%E7%A8%8B">进程</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="http://blog.gusibi.site/post/golang-learning-note-1/">
              <h3 class="post-title">
                Golang 学习笔记-1：变量&amp;函数
              </h3>
            </a>
          </div>
        

        
          

          
            <link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css">
<script src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>

<div id="disqus_thread"></div>

<script>

var options = {
  shortname: 'gu-si-bi',
  apikey: '',
}
if ('') {
  options.api = ''
}
var dsqjs = new DisqusJS(options)

</script>

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="http://blog.gusibi.site/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
