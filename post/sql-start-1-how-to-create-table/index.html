<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>数据库基础：创建表 | 顾斯比</title>
<link rel="shortcut icon" href="http://blog.gusibi.site/favicon.ico?v=1593195803130">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="http://blog.gusibi.site/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="数据库基础：创建表 | 顾斯比 - Atom Feed" href="http://blog.gusibi.site/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-76238744-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-76238744-1');
</script>


    <meta name="description" content="数据库基础
数据库
数据库是保存有组织的数据的容器（通常是一个文件或一组文件）。
一个 excel 文件。
这里是一个 excel 文件图片

这里是一个数据库图片


通常人们用数据库代表他们使用的数据库软件。不过确切的说，数据库软件应称..." />
    <meta name="keywords" content="database" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="http://blog.gusibi.site">
  <img class="avatar" src="http://blog.gusibi.site/images/avatar.png?v=1593195803130" alt="">
  </a>
  <h1 class="site-title">
    顾斯比
  </h1>
  <p class="site-description">
    这个人很懒
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/gusibi" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
        <a href="https://twitter.com/amazing_gs" target="_blank">
          <i class="ri-twitter-line"></i>
        </a>
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              数据库基础：创建表
            </h2>
            <div class="post-info">
              <span>
                2017-07-30
              </span>
              <span>
                20 min read
              </span>
              
                <a href="http://blog.gusibi.site/tag/SS95MaqZ5J/" class="post-tag">
                  # database
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="数据库基础">数据库基础</h2>
<h3 id="数据库">数据库</h3>
<p>数据库是保存有组织的数据的容器（通常是一个文件或一组文件）。</p>
<p>一个 excel 文件。</p>
<p><strong>这里是一个 excel 文件图片</strong></p>
<figure data-type="image" tabindex="1"><img src="http://media.gusibi.mobi/WzFaDj_ugK7JLrtKzU-L9oTWY5qSXEHa0FszhV8gQicJWSZtHsXFss34r-TkRUJQ" alt="这里是一个 excel 文件图片" loading="lazy"></figure>
<p><strong>这里是一个数据库图片</strong></p>
<figure data-type="image" tabindex="2"><img src="http://media.gusibi.mobi/GtovdBEGv1VzGyeGImgE45jrJuakyx9-Bmkltwm5kNgKpKrgBB00sk_1yPC_IgnC" alt="这里是一个数据库图片" loading="lazy"></figure>
<blockquote>
<p>通常人们用数据库代表他们使用的数据库软件。不过确切的说，数据库软件应称作数据库管理系统。</p>
</blockquote>
<h3 id="表">表</h3>
<p>表是某种特定数据的结构化清单。</p>
<p>excel 中的 sheet。</p>
<p>数据库中每个表都有一个自己的名字来标识自己，这个名字是唯一的，即数据库中没有其他表具有相同的名字。（不同的数据库可以有不同的名字）</p>
<p><strong>这里是一个 sheet结构</strong></p>
<figure data-type="image" tabindex="3"><img src="http://media.gusibi.mobi/NCnjCS_QjOinK0X1e1p5uTvx7iYjTfFGZE_rn8CRk-m_mNZbrsqzq2kaUYqpTSCT" alt="这里是一个 sheet结构" loading="lazy"></figure>
<p><strong>这里是一个表结构</strong></p>
<figure data-type="image" tabindex="4"><img src="http://media.gusibi.mobi/AOjmnriLW8FxYAQqBUcZJSw-9NrzJ3rZPrqjfJf0MGBLQjTfhp1urWCRc9PRxIF5" alt="这里是一个表结构" loading="lazy"></figure>
<blockquote>
<p>表具有一些特性，这些特性定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。描述表的这组信息就是所谓的模式，模式可以用来描述数据库中特定的表，也可以描述整个数据库。</p>
</blockquote>
<h3 id="列和数据类型">列和数据类型</h3>
<p>表由列组成。列存储表中某部分的信息。</p>
<blockquote>
<p>列是表中的一个字段。所有表都是由一个或多个列组成。</p>
</blockquote>
<p><strong>这是表结构</strong></p>
<figure data-type="image" tabindex="5"><img src="http://media.gusibi.mobi/iUwFYgJyLqZoJ88D0AWfHHKS3aOtPrK7q_l98-PUyeMQ2DJrHAkUjOdrYhcagOe2" alt="这是表结构，指出哪些是列" loading="lazy"></figure>
<p>每一列存储着某种特定的信息。例如在顾客表中，一列存储顾客编号，另一列存储顾客姓名，而地址、城市、州以及邮编全都存储在各自的列中。</p>
<p>数据库中每个列都有相应的数据类型。数据类型(datatype)定义了列可以存储哪些数据种类。例如，如果列中存储的是数字(或许是订单中的物品数)，则相应的数据类型应该为数值类型。如果列中存储的是日期、文本、注释、金额等，则应该规定好恰当的数据类型。</p>
<blockquote>
<p>数据类型是每列所允许的类型。每个列都有相应的数据类型，它限制该列中存储的数据。<br>
数据类型限定了可存储在列中的数据种类(例如，防止在数值字段中录入字符值)。数据类型还帮助正确地分类数据。因此，在创建表时必须特别关注所用的数据类型。</p>
</blockquote>
<h3 id="行">行</h3>
<blockquote>
<p>行是表中的一个记录。</p>
</blockquote>
<p>表中的数据是按行存储的，所保存的每个记录存储在自己的行内。</p>
<h3 id="主键">主键</h3>
<p>一列(或一组列)，其值能够唯一标识表中每一行。（用户表的用户 ID，问题表的问题 ID）</p>
<blockquote>
<p>表可以不创建主键，正常情况下，我们都会给每个表创建一个主键，以便以后的数据操作和管理。</p>
</blockquote>
<p>每个列都可以做主键，需要的条件：</p>
<ul>
<li>任意两行都不具有相同的主键值;</li>
<li>每一行都必须具有一个主键值(主键列不允许NULL值);</li>
<li>主键列中的值不允许修改或更新;</li>
<li>主键值不能重用(如果某行从表中删除，它的主键不能赋给以后的新行)</li>
</ul>
<h2 id="操作表">操作表</h2>
<h3 id="创建表">创建表</h3>
<p>创建表用到的命令是 <code>CREATE TABLE</code>，需要注意的点为：</p>
<ol>
<li>给表起一个独特（不能和其它表重名）的名字</li>
<li>然后在括号内来定义每一列的列表，在表中是什么样的数据类型以及要加的限制（比如，不能重复，最长多少字符..)</li>
</ol>
<pre><code class="language-sql">CREATE TABLE account(
 user_id integer PRIMARY KEY, 
 username VARCHAR (50) UNIQUE NOT NULL,
 password VARCHAR (50) NOT NULL,
 created_on TIMESTAMP NOT NULL DEFAULT now(),
 last_login TIMESTAMP
);
</code></pre>
<p>表名： account<br>
列名： user_id, username, password, created_on, last_login<br>
PRIMARY KEY: 表明这是主键。<br>
UNIQUE: 表明这个字段值不能重复。<br>
NOT NULL: 表明该列不能为空。<br>
DEFAULT: 用来指定默认值。</p>
<h3 id="删除表">删除表</h3>
<pre><code class="language-sql">DROP TABLE account;
</code></pre>
<h3 id="更新表">更新表</h3>
<blockquote>
<p>更新操作</p>
</blockquote>
<h2 id="插入数据">插入数据</h2>
<h3 id="数据插入">数据插入</h3>
<p>语法格式：</p>
<pre><code class="language-sql">INSERT INTO TABLE_NAME (column1, column2, column3,...columnN)  
VALUES (value1, value2, value3,...valueN);
</code></pre>
<blockquote>
<p><code>column1</code>, <code>column2</code>, <code>column3</code>,...<code>columnN</code> 是要插入数据的表中的列的名称。</p>
</blockquote>
<h4 id="插入完整的行">插入完整的行</h4>
<pre><code class="language-sql">INSERT INTO account (user_id, username, password, created_on, last_login)  
VALUES (1, 'fenda', 'fenda123', now(), now());
</code></pre>
<blockquote>
<p>重复执行会报错，因为 user_id 和 username 不能重复。</p>
</blockquote>
<h4 id="插入部分行">插入部分行</h4>
<p>可为空的，设置了默认值的字段可以不设定值。</p>
<pre><code class="language-sql">INSERT INTO account (user_id, username, password)  
VALUES (2, 'zaihang', 'fenda123');
</code></pre>
<p>这里，created_on 和 last_login 并没有指定值。</p>
<h2 id="检索数据">检索数据</h2>
<p>SQL语句是由简单的英语单词构成的。这些单词称为关键字，每个SQL语句都是由一个或多个关键字构成的。最经常使用的SQL语句大概就是SELECT语句了SELECT语句了。它的用途是从一个或多个表中检索信息。</p>
<blockquote>
<p>为了使用SELECT检索表数据，必须至少给出两条信息——想选择什么，以及从什么地方选择</p>
</blockquote>
<h3 id="检索单个列">检索单个列</h3>
<pre><code class="language-sql">select user_id from account;
</code></pre>
<blockquote>
<p>上述语句利用SELECT语句从 account 表中检索一个名为 user_id 的列。所需的列名写在SELECT关键字之后，FROM关键字指出从哪个表中检索。</p>
</blockquote>
<p>这条SELECT语句将返回表中的所有行。数据没有过滤(过滤将得出结果集的一个子集)，也没有排序。</p>
<p><strong>注意</strong></p>
<ul>
<li>多条SQL语句必须以分号(;)分隔。多数DBMS不需要在单条SQL语句后加分号，但Postgresql必须在单条SQL语句后加上分号。当然，如果愿意可以总是加上分号。事实上，即使不一定需要，加上分号也肯定没有坏处。</li>
<li><code>SQL语句不区分大小写</code>，因此SELECT与select是相同的。</li>
<li>在处理SQL语句时，其中所有空格都被忽略。SQL语句可以写成长长的一行，也可以分写在多行。下面这三种写法的作用是一样的。</li>
</ul>
<pre><code class="language-sql">-- 1
select user_id from account;

-- 2
select user_id
from account;

-- 3
select
user_id
from
account;
</code></pre>
<blockquote>
<p>SQL 使用 <code>双横线（--）</code> 注释</p>
</blockquote>
<h3 id="什么时候需要注释">什么时候需要注释</h3>
<ul>
<li>SQL语句变长，复杂性增加时，你就会想添加一些描述性的注释，这便于你自己今后参考，或者供项目后续参与人员参考；</li>
<li>在SQL文件开始处添加程序员的联系方式、程序描述以及一些说明的内容。</li>
<li>暂时停止要执行的SQL代码。如果你碰到一个长SQL语句，而只想测试它的一部分，那么应该注释掉一些代码， 以便数据库将其视为注释而加以忽略。</li>
</ul>
<pre><code class="language-sql">select user_id  -- 这是注释（可是试试把 -- 去掉看会发生什么）
from account;

/* SELECT user_id,  FROM account; */
SELECT username
FROM account;
</code></pre>
<h3 id="检索多个列">检索多个列</h3>
<pre><code class="language-sql">select user_id, username from account;
</code></pre>
<h3 id="检索所有列">检索所有列</h3>
<pre><code class="language-sql">select * from account;
</code></pre>
<h3 id="限制结果">限制结果</h3>
<pre><code class="language-sql">select * from account limit 1;

select * from account where user_id&gt; 1 limit 1;
</code></pre>
<h2 id="排序检索数据">排序检索数据</h2>
<p><code>ORDER BY</code> 对产生的输出排序。</p>
<h3 id="排序数据">排序数据</h3>
<pre><code class="language-sql">select * from trade where operate_type='recharge' order by operate_fee; -- 按充值金额从小到大

select * from trade where operate_type='recharge' order by operate_fee desc; -- 按充值金额从大到小
</code></pre>
<h3 id="按多个列排序">按多个列排序</h3>
<pre><code class="language-sql">-- 按充值金额从小到大 金额相同的按充值时间从大到小
select * from trade where operate_type='recharge' order by operate_fee, date_created desc; 

-- 按充值金额从大到小 金额相同的按充值金额从小到大
select * from trade where operate_type='recharge' order by operate_fee desc, date_created; 
</code></pre>
<h2 id="过滤数据">过滤数据</h2>
<h3 id="使用-where-子句">使用 where 子句</h3>
<pre><code class="language-sql">select * from trade where where operate_type='recharge' and operate_fee &gt; 1000 limit 1;
</code></pre>
<h3 id="where-子句操作符">where 子句操作符</h3>
<pre><code class="language-sql">select * from trade where operate_fee = 1000;

select * from trade where operate_fee &gt; 1000;

select * from trade where operate_fee &gt;= 1000;

select * from trade where operate_fee &lt; 1000;

select * from trade where operate_fee &lt;= 1000;
</code></pre>
<h3 id="组合-where-子句">组合 where 子句</h3>
<pre><code class="language-sql">select * from trade where operate_fee &lt;= 1000 and date_created &gt; '2017-04-05';

select * from trade where date_created &lt; '2017-08-05' and date_created &gt; '2017-04-05';

select * from trade where date_created &gt; '2017-07-05' or date_created &lt; '2017-04-05';
</code></pre>
<h4 id="求值顺序">求值顺序</h4>
<pre><code class="language-sql">-- 先组合 date_created &lt; '2017-04-05' and operate_fee &gt; 1000 
-- 再判断 date_created &gt; '2017-07-05'
-- 意思是 查询创建时间大于 2017-07-05 和 创建于 2017-04-05 之前的
-- 金额大于1000的充值数据。
select * from trade 
    where date_created &gt; '2017-07-05' 
    or date_created &lt; '2017-04-05' 
    and operate_fee &gt; 1000 
    and operate_type='recharge';

-- 查询 创建时间在 2017-04-05 之前 
-- 或者 2017-07-05之后的 充值金额大于1000的订单
select * from trade 
    where (date_created &gt; '2017-07-05' 
        or date_created &lt; '2017-04-05') 
    and operate_fee &gt; 1000
    and operate_type='recharge';
</code></pre>
<h3 id="in-操作">in 操作</h3>
<p><strong>查询充值金额为1000 或者 600 的订单</strong></p>
<pre><code class="language-sql">select * from trade where operate_fee in (600, 1000) and operate_type='recharge';

-- 等同于 

select * from trade where (operate_fee = 600 or operate_fee = 1000) and operate_type='recharge';
</code></pre>
<p>为什么要使用IN操作符?其优点为:</p>
<ul>
<li>在有很多合法选项时，IN操作符的语法更清楚，更直观。</li>
<li>在与其他AND和OR操作符组合使用IN时，求值顺序更容易管理。</li>
<li>IN操作符一般比一组OR操作符执行得更快(在上面这个合法选项很少的例子中，你看不出性能差异)。</li>
<li>IN的最大优点是可以包含其他SELECT语句，能够更动态地建立WHERE子句。</li>
</ul>
<h3 id="not-操作符">not 操作符</h3>
<p>WHERE子句中的NOT操作符有且只有一个功能，那就是否定其后所跟的任何条件。因为NOT从不单独使用(它总是与其他操作符一起使用)，<br>
所以它的语法与其他操作符有所不同。NOT关键字可以用在要过滤的列前，而不仅是在其后。</p>
<blockquote>
<p><code>NOT</code><br>
WHERE子句中用来否定其后条件的关键字。</p>
</blockquote>
<pre><code class="language-sql">select * from trade where not operate_fee in (600, 1000) and operate_type='recharge' LIMIT 10;

SELECT * FROM trade WHERE operate_fee NOT IN (600, 1000) AND operate_type='recharge' LIMIT 10;

SELECT * FROM trade WHERE NOT (operate_fee IN (600, 1000) AND operate_type='recharge') LIMIT 10;
</code></pre>
<h2 id="like-操作符">like 操作符</h2>
<p>前面介绍的所有操作符都是针对已知值进行过滤的。不管是匹配一个值还是多个值，检验大于还是小于已知值，或者检查某个范围的值，其共<br>
同点是过滤中使用的值都是已知的。</p>
<p>但是，这种过滤方法并不是任何时候都好用。例如，我们想找出 <code>account</code> 表中 username 以 <code>fenda</code> 开头的数据。</p>
<p>这时，就必须使用通配符了。</p>
<blockquote>
<p><code>通配符(wildcard)</code> 用来匹配值的一部分的特殊字符。<br>
<code>搜索模式(search pattern)</code> 由字面值、通配符或两者组合构成的搜索条件。</p>
</blockquote>
<p>SQL支持几种通配符。为在搜索子句中使用通配符，必须使用LIKE操作符。LIKE指示数据库，后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较。</p>
<blockquote>
<p><code>注意：</code>通配符搜索只能用于文本字段(串)，非文本数据类型字段不能使用通配符搜索。</p>
</blockquote>
<h3 id="百分号通配符">百分号(%)通配符</h3>
<p>最常使用的通配符是百分号(%)。在搜索串中，%表示任何字符出现任意次数。</p>
<pre><code class="language-sql">select * from account where username like 'fenda%';
</code></pre>
<p>此例子使用了搜索模式'fenda%'。在执行这条子句时，将检索任意以 <code>fenda</code> 起头的词。<code>%``告诉数据库接受</code>fenda` 之后的任意字符，不管它有多少字符。</p>
<blockquote>
<p>搜索模式区分大小写。 <code>'Fenda%'</code> 和 <code>'fenda%'</code> 是不同的。</p>
</blockquote>
<p><code>%</code> 不仅可以放在最后，也可以放在其他位置，比如</p>
<pre><code class="language-sql">select * from account where username like '%enda%';
</code></pre>
<h3 id="下划线_通配符">下划线(_)通配符</h3>
<p>下划线的用途与%一样，但它只匹配单个字符，而不是多个字符。</p>
<pre><code class="language-sql">select * from account where username like 'fenda-_bc-9';
</code></pre>
<h3 id="方括号-通配符">方括号([ ])通配符</h3>
<p>方括号([])通配符用来指定一个字符集，它必须匹配指定位置(通配符的位置)的一个字符。</p>
<pre><code class="language-sql">-- bc 前边的字符只能是 a 或 b
select * from account where username like 'fenda-[ab]bc-9';

-- bc 前边的字符不能是 a 或 b
select * from account where username like 'fenda-[^ab]bc-9';
</code></pre>
<h3 id="通配符转义">通配符转义</h3>
<pre><code class="language-sql">-- abc 前只能是 下划线(_)
select * from account where username like 'fenda[_]abc-9';

-- 使用转义字符声明下划线是一个字符而不是通配符
select * from account where username like 'fenda\_abc-9';
</code></pre>
<h3 id="使用通配符的技巧">使用通配符的技巧</h3>
<p>通配符搜索一般比前面讨论的其他搜索要耗费更长的处理时间。这里给出一些使用通配符时要记住的技巧。</p>
<ul>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li>
<li>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。</li>
<li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li>
</ul>
<h2 id="汇总数据">汇总数据</h2>
<p>我们经常需要汇总数据而不用把它们实际检索出来，为此SQL提供了专门的函数。使用这些函数，SQL查询可用于检索数据，以便分析和报表生成。这种类型的检索例子有:</p>
<ul>
<li>确定表中行数(或者满足某个条件或包含某个特定值的行数);</li>
<li>获得表中某些行的和;</li>
<li>找出表列(或所有行或某些特定的行)的最大值、最小值、平均值。</li>
</ul>
<p>SQL 提供的常用的聚集函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>COUNT()</td>
<td>返回某列的行数</td>
</tr>
<tr>
<td>AVG()</td>
<td>返回某列的平均值</td>
</tr>
<tr>
<td>MAX()</td>
<td>返回某列的最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>返回某列的最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>返回某列的和</td>
</tr>
</tbody>
</table>
<h3 id="avg-函数">AVG() 函数</h3>
<p>AVG()通过对表中行数计数并计算其列值之和，求得该列的平均值。AVG()可用来返回所有列的平均值，也可以用来返回特定列或行的平均值。</p>
<p>下面的例子使用AVG()返回 trade 表中所有充值数据的均值:</p>
<pre><code class="language-sql">-- 充值金额的均值
select avg(operate_fee) from trade 
    where operate_type='recharge';
</code></pre>
<blockquote>
<p>AVG()函数忽略列值为NULL的行。</p>
</blockquote>
<h3 id="count-函数">COUNT() 函数</h3>
<p>COUNT()函数进行计数。可利用COUNT()确定表中行的数目或符合特定条件的行的数目。</p>
<p>COUNT()函数有两种使用方式:</p>
<ul>
<li>使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值(NULL)还是非空值。</li>
<li>使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。</li>
</ul>
<p>比如：</p>
<pre><code class="language-sql">select count(*) from account;  -- 用户数

select count(last_login) from account; -- 登录过的用户数
</code></pre>
<blockquote>
<p>如果指定列名，则COUNT()函数会忽略指定列的值为空的行，但如果COUNT()函数中用的是星号(*)，则不忽略。</p>
</blockquote>
<h3 id="max-函数">MAX() 函数</h3>
<p>MAX()返回指定列中的最大值。MAX()要求指定列名，如下所示:</p>
<pre><code class="language-sql">-- 充值数据中的最高金额
select max(operate_fee) from trade where operate_type='recharge'; 

select operate_fee from trade 
    where operate_type='recharge' 
    order by operate_fee desc limit 1;
</code></pre>
<blockquote>
<p>MAX()函数忽略列值为NULL的行。</p>
</blockquote>
<h3 id="min-函数">MIN() 函数</h3>
<p>MIN()的功能正好与MAX()功能相反，它返回指定列的最小值。与MAX()一样，MIN()要求指定列名，如下所示:</p>
<pre><code class="language-sql">-- 充值数据中的最少金额
select min(operate_fee) from trade where operate_type='recharge'; 

select operate_fee from trade 
    where operate_type='recharge' 
    order by operate_fee limit 1;
</code></pre>
<blockquote>
<p>MIN()函数忽略列值为NULL的行。</p>
</blockquote>
<h3 id="sum-函数">SUM() 函数</h3>
<pre><code class="language-sql">-- 最大的充值金额
SELECT max(operate_fee) FROM trade WHERE operate_type='recharge';

-- 以最大充值金额充值的条数
SELECT count(*) FROM trade 
    WHERE operate_type='recharge' 
    AND operate_fee = (SELECT max(operate_fee) FROM trade 
                       WHERE operate_type='recharge');

SELECT operate_fee * (SELECT count(*) FROM trade 
                          WHERE operate_type='recharge' 
                          AND operate_fee = (SELECT max(operate_fee) FROM trade 
                              WHERE operate_type='recharge')) AS 最大充值金额总和 FROM trade 
    WHERE operate_type='recharge' 
    AND operate_fee=(SELECT max(operate_fee) FROM trade 
                     WHERE operate_type='recharge');

SELECT sum(operate_fee) AS 最大充值金额总和 FROM trade 
    WHERE operate_type='recharge' 
    AND operate_fee = (SELECT max(operate_fee) FROM trade 
                       WHERE operate_type='recharge');
</code></pre>
<p>SUM()用来返回指定列值的和(总计)。比如:</p>
<pre><code class="language-sql">-- 充值金额的总和
select sum(operate_fee) from trade where operate_type='recharge'; 

-- 充值金额的总和
select sum(operate_fee) from trade where operate_type='recharge';
</code></pre>
<h3 id="组合聚集函数">组合聚集函数</h3>
<p>SELECT语句可根据需要包含多个聚集函数。请看下面的例子:</p>
<pre><code class="language-sql">SELECT count(*) AS 总充值条数,
    min(operate_fee) AS 最小充值金额,
    max(operate_fee) AS 最大充值金额,
    avg(operate_fee) AS fee_avg,
    sum(operate_fee) AS fee_sum
FROM trade WHERE operate_type='recharge';
</code></pre>
<h4 id="练习-计算最大的充值金额并统计最大金额的充值次数">练习： 计算最大的充值金额，并统计最大金额的充值次数</h4>
<pre><code class="language-sql">SELECT count(*) FROM trade 
    WHERE operate_type='recharge' 
    AND operate_fee=(
        SELECT max(operate_fee) FROM trade 
            WHERE operate_type='recharge');
</code></pre>
<h4 id="练习计算最大的充值金额并统计以这个金额充值的总金额">练习：计算最大的充值金额，并统计以这个金额充值的总金额</h4>
<pre><code class="language-sql">SELECT sum(operate_fee) FROM trade 
    WHERE operate_type='recharge' 
    AND operate_fee = (
        SELECT max(operate_fee) FROM trade 
            WHERE operate_type='recharge');
</code></pre>
<p>这条 select 语句执行了5个聚合函数，返回5个值（总充值次数，最小值，最大值，平均值，总充值金额）。</p>
<blockquote>
<p><code>取别名</code> 使用聚合函数时，建议使用别名指定计算后的结果。在指定别名时，不应该使用表中实际的列名。</p>
</blockquote>
<h2 id="分组数据">分组数据</h2>
<p>使用SQL聚集函数可以汇总数据。这样，我们就能够对行进行计数，计算和与平均数，不检索所有数据就获得最大值和最小值。<br>
目前为止的所有计算都是在表的所有数据或匹配特定的WHERE子句的数据上进行的。比如下面的例子返回供应商DLL01提供的产品数目:</p>
<pre><code class="language-sql">SELECT COUNT(*) AS num_prods FROM Products
WHERE vend_id = 'DLL01';
</code></pre>
<p>如果要返回每个供应商提供的产品数目，该怎么办?或者返回只提供一项产品的供应商的产品，或者返回提供10个以上产品的供应商的产品，怎么办?<br>
这就是分组大显身手的时候了。使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算。</p>
<h3 id="创建分组">创建分组</h3>
<p>分组是使用SELECT语句的<code>GROUP BY</code>子句建立的。理解分组的最好办法是看一个例子:</p>
<pre><code class="language-sql">-- 查询每个用户充值的次数
select account_id, count(*) AS 充值次数 from trade 
    where operate_type='recharge' 
    group by account_id;
</code></pre>
<p>上面的<code>SELECT</code>语句指定了两个列: account_id 包含用户的ID，<code>充值次数</code>为计算字段(用COUNT(*)函数建立)。<code>GROUP BY</code>子句指示 数据库按 <code>account_id</code>排序并分组数据。这就会对每个<code>account_id</code>而不是整个表计算充值次数一次。<br>
因为使用了<code>GROUP BY</code>，就不必指定要计算和估值的每个组了。系统会自动完成。<code>GROUP BY</code>子句指示数据库分组数据，然后对每个组而不是整个结果集进行聚集。</p>
<ul>
<li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</li>
<li>除聚集计算语句外，SELECT语句中的每一列都必须在GROUP BY子句中给出。</li>
<li>如果分组列中包含具有NULL值的行，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</li>
</ul>
<h3 id="过滤分组">过滤分组</h3>
<p>除了能用GROUP BY分组数据外，SQL还允许过滤分组，规定包括哪些分组，排除哪些分组。例如，你可能想要列出至少充值两次的用户。为此，必须基于完整的分组而不是个别的行进行过滤。</p>
<p>SQL为此提供了另一个子句，就是<code>HAVING</code>子句。HAVING非常类似于WHERE。WHERE过滤行，而 <code>HAVING</code> 过滤分组。</p>
<pre><code class="language-sql">-- 查询充值的次数大于10的用户
select account_id, count(*) AS 充值次数 from trade 
    where operate_type='recharge' 
    group by account_id
    having count(*) &gt; 10;
</code></pre>
<blockquote>
<p>WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重要的区别，WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组</p>
</blockquote>
<h3 id="分组和排序">分组和排序</h3>
<p>使用 <code>GROUP BY</code> 分组的结果是无序的，我们可以使用 <code>ORDER BY</code> 对结果进行排序。</p>
<pre><code class="language-sql">-- 查询充值的次数大于10的用户 按充值次数排序
SELECT account_id, count(*) AS 充值次数 FROM trade 
    WHERE operate_type='recharge' 
    GROUP BY account_id
    HAVING count(*) &gt; 10
    ORDER BY count(*) desc;
</code></pre>
<h2 id="参考链接">参考链接</h2>
<hr>
<p>最后，感谢女朋友支持。</p>
<table>
<thead>
<tr>
<th>欢迎关注(April_Louisa)</th>
<th>请我喝芬达</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="http://media.gusibi.mobi/Hy8XHexmzppNKuekLuGxWy8LjdGrQAzZA3mH_e9xltoiYgTFWdvlpZwGWxZESrbK" alt="欢迎关注" loading="lazy"></td>
<td><img src="http://media.gusibi.mobi/CO9DwU6ZHnXHD5xuG3GqTsY_IYPl-JdpQrDaOo6tl6PiAGEBDeYFHO7sGQi_VVFc" alt="请我喝芬达" loading="lazy"></td>
</tr>
</tbody>
</table>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80">数据库基础</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></li>
<li><a href="#%E8%A1%A8">表</a></li>
<li><a href="#%E5%88%97%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">列和数据类型</a></li>
<li><a href="#%E8%A1%8C">行</a></li>
<li><a href="#%E4%B8%BB%E9%94%AE">主键</a></li>
</ul>
</li>
<li><a href="#%E6%93%8D%E4%BD%9C%E8%A1%A8">操作表</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E8%A1%A8">创建表</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E8%A1%A8">删除表</a></li>
<li><a href="#%E6%9B%B4%E6%96%B0%E8%A1%A8">更新表</a></li>
</ul>
</li>
<li><a href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">插入数据</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5">数据插入</a>
<ul>
<li><a href="#%E6%8F%92%E5%85%A5%E5%AE%8C%E6%95%B4%E7%9A%84%E8%A1%8C">插入完整的行</a></li>
<li><a href="#%E6%8F%92%E5%85%A5%E9%83%A8%E5%88%86%E8%A1%8C">插入部分行</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE">检索数据</a>
<ul>
<li><a href="#%E6%A3%80%E7%B4%A2%E5%8D%95%E4%B8%AA%E5%88%97">检索单个列</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E6%B3%A8%E9%87%8A">什么时候需要注释</a></li>
<li><a href="#%E6%A3%80%E7%B4%A2%E5%A4%9A%E4%B8%AA%E5%88%97">检索多个列</a></li>
<li><a href="#%E6%A3%80%E7%B4%A2%E6%89%80%E6%9C%89%E5%88%97">检索所有列</a></li>
<li><a href="#%E9%99%90%E5%88%B6%E7%BB%93%E6%9E%9C">限制结果</a></li>
</ul>
</li>
<li><a href="#%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE">排序检索数据</a>
<ul>
<li><a href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE">排序数据</a></li>
<li><a href="#%E6%8C%89%E5%A4%9A%E4%B8%AA%E5%88%97%E6%8E%92%E5%BA%8F">按多个列排序</a></li>
</ul>
</li>
<li><a href="#%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE">过滤数据</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8-where-%E5%AD%90%E5%8F%A5">使用 where 子句</a></li>
<li><a href="#where-%E5%AD%90%E5%8F%A5%E6%93%8D%E4%BD%9C%E7%AC%A6">where 子句操作符</a></li>
<li><a href="#%E7%BB%84%E5%90%88-where-%E5%AD%90%E5%8F%A5">组合 where 子句</a>
<ul>
<li><a href="#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F">求值顺序</a></li>
</ul>
</li>
<li><a href="#in-%E6%93%8D%E4%BD%9C">in 操作</a></li>
<li><a href="#not-%E6%93%8D%E4%BD%9C%E7%AC%A6">not 操作符</a></li>
</ul>
</li>
<li><a href="#like-%E6%93%8D%E4%BD%9C%E7%AC%A6">like 操作符</a>
<ul>
<li><a href="#%E7%99%BE%E5%88%86%E5%8F%B7%E9%80%9A%E9%85%8D%E7%AC%A6">百分号(%)通配符</a></li>
<li><a href="#%E4%B8%8B%E5%88%92%E7%BA%BF_%E9%80%9A%E9%85%8D%E7%AC%A6">下划线(_)通配符</a></li>
<li><a href="#%E6%96%B9%E6%8B%AC%E5%8F%B7-%E9%80%9A%E9%85%8D%E7%AC%A6">方括号([ ])通配符</a></li>
<li><a href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E8%BD%AC%E4%B9%89">通配符转义</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E6%8A%80%E5%B7%A7">使用通配符的技巧</a></li>
</ul>
</li>
<li><a href="#%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE">汇总数据</a>
<ul>
<li><a href="#avg-%E5%87%BD%E6%95%B0">AVG() 函数</a></li>
<li><a href="#count-%E5%87%BD%E6%95%B0">COUNT() 函数</a></li>
<li><a href="#max-%E5%87%BD%E6%95%B0">MAX() 函数</a></li>
<li><a href="#min-%E5%87%BD%E6%95%B0">MIN() 函数</a></li>
<li><a href="#sum-%E5%87%BD%E6%95%B0">SUM() 函数</a></li>
<li><a href="#%E7%BB%84%E5%90%88%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0">组合聚集函数</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0-%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%85%E5%80%BC%E9%87%91%E9%A2%9D%E5%B9%B6%E7%BB%9F%E8%AE%A1%E6%9C%80%E5%A4%A7%E9%87%91%E9%A2%9D%E7%9A%84%E5%85%85%E5%80%BC%E6%AC%A1%E6%95%B0">练习： 计算最大的充值金额，并统计最大金额的充值次数</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%85%E5%80%BC%E9%87%91%E9%A2%9D%E5%B9%B6%E7%BB%9F%E8%AE%A1%E4%BB%A5%E8%BF%99%E4%B8%AA%E9%87%91%E9%A2%9D%E5%85%85%E5%80%BC%E7%9A%84%E6%80%BB%E9%87%91%E9%A2%9D">练习：计算最大的充值金额，并统计以这个金额充值的总金额</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE">分组数据</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%88%86%E7%BB%84">创建分组</a></li>
<li><a href="#%E8%BF%87%E6%BB%A4%E5%88%86%E7%BB%84">过滤分组</a></li>
<li><a href="#%E5%88%86%E7%BB%84%E5%92%8C%E6%8E%92%E5%BA%8F">分组和排序</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="http://blog.gusibi.site/post/css-learing-3-positioning-elements/">
              <h3 class="post-title">
                CSS入门指南-3：定位元素
              </h3>
            </a>
          </div>
        

        
          

          
            <link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css">
<script src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>

<div id="disqus_thread"></div>

<script>

var options = {
  shortname: 'gu-si-bi',
  apikey: '',
}
if ('') {
  options.api = ''
}
var dsqjs = new DisqusJS(options)

</script>

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="http://blog.gusibi.site/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
